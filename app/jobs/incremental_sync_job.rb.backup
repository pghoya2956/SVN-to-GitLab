class IncrementalSyncJob
  include Sidekiq::Job
  
  sidekiq_options retry: 3, dead: false
  
  sidekiq_retry_in do |count, exception|
    case count
    when 0
      60 # 1 minute
    when 1
      300 # 5 minutes
    when 2
      600 # 10 minutes
    end
  end
  
  def perform(repository_id)
    @repository = Repository.find(repository_id)
    @user = @repository.user
    
    # Set current user for default scope
    User.current = @user
    
    # Create a job record
    @job = @repository.jobs.create!(
      user: @user,
      job_type: 'incremental_sync',
      status: 'pending',
      parameters: { repository_id: repository_id }.to_json
    )
    
    begin
      @job.mark_as_running!
      
      if @repository.local_git_exists?
        perform_incremental_sync
      else
        perform_initial_sync
      end
      
      @job.mark_as_completed!
    rescue => e
      @job.mark_as_failed!(e.message)
      raise e
    ensure
      User.current = nil
    end
  end
  
  private
  
  def perform_initial_sync
    @job.append_output("No local Git repository found. Performing initial sync...")
    @job.update(progress: 10)
    
    # Create local git directory
    local_path = Rails.root.join('repositories', @user.id.to_s, @repository.id.to_s)
    FileUtils.mkdir_p(local_path)
    
    Dir.chdir(local_path) do
      # Initialize git-svn
      @job.append_output("Initializing git-svn...")
      @job.update(progress: 20)
      
      cmd = build_git_svn_clone_command
      execute_command(cmd, "git-svn clone")
      
      @job.update(progress: 60)
      
      # Add GitLab remote
      add_gitlab_remote
      
      # Push to GitLab
      @job.append_output("Pushing to GitLab...")
      @job.update(progress: 80)
      
      push_to_gitlab
      
      # Update repository record
      @repository.update!(
        local_git_path: local_path.to_s,
        last_synced_at: Time.current,
        last_synced_revision: get_latest_svn_revision
      )
    end
    
    @job.update(progress: 100)
    @job.append_output("Initial sync completed successfully!")
  end
  
  def perform_incremental_sync
    @job.append_output("Performing incremental sync...")
    @job.update(progress: 10)
    
    # Check if git directory exists
    unless @repository.local_git_path.present?
      raise "Local git path not set. Please run initial migration first."
    end
    
    git_dir = @repository.git_directory
    unless File.directory?(git_dir)
      raise "Git directory not found: #{git_dir}. Please run initial migration first."
    end
    
    # Create temp directory for SVN checkout
    temp_dir = Rails.root.join('tmp', 'sync', @job.id.to_s)
    FileUtils.mkdir_p(temp_dir)
    svn_path = temp_dir.join('svn_checkout')
    
    begin
      # Checkout latest SVN
      @job.append_output("Checking out latest SVN...")
      @job.update(progress: 30)
      
      checkout_latest_svn(svn_path)
      
      # Sync changes to git repo
      @job.append_output("Syncing changes to git repository...")
      @job.update(progress: 50)
      
      sync_changes_to_git(svn_path, git_dir)
      
      # Push to GitLab
      @job.append_output("Pushing changes to GitLab...")
      @job.update(progress: 70)
      
      push_to_gitlab_from_dir(git_dir)
      
      # Update sync timestamp
      @repository.update!(
        last_synced_at: Time.current,
        last_synced_revision: get_latest_svn_revision_from_checkout(svn_path)
      )
      
      @job.update(progress: 100)
      @job.append_output("Incremental sync completed successfully!")
      
    ensure
      # Cleanup temp files
      FileUtils.rm_rf(temp_dir) if temp_dir && File.exist?(temp_dir)
    end
  end
  
  def checkout_latest_svn(svn_path)
    cmd = ['svn', 'checkout']
    
    # Add authentication
    if @repository.auth_type == 'basic'
      cmd << '--username' << @repository.username if @repository.username.present?
      cmd << '--password' << @repository.password if @repository.password.present?
    end
    
    # Only checkout HEAD revision for speed
    cmd << '-r' << 'HEAD'
    cmd << @repository.svn_url << svn_path.to_s
    
    execute_svn_command(cmd, "SVN checkout")
  end
  
  def sync_changes_to_git(svn_path, git_dir)
    # Copy SVN files to git directory (excluding .svn directories)
    @job.append_output("Copying SVN files to git repository...")
    
    # First, remove all tracked files from git (but keep .git directory)
    Open3.popen3('git', 'ls-files', '-z', chdir: git_dir) do |stdin, stdout, stderr, wait_thr|
      files = stdout.read.split("\0")
      files.each do |file|
        file_path = File.join(git_dir, file)
        FileUtils.rm_f(file_path) if File.exist?(file_path)
      end
    end
    
    # Copy new files from SVN
    Dir.glob("#{svn_path}/**/*", File::FNM_DOTMATCH).each do |src|
      next if src.include?('/.svn/') || src.end_with?('/.svn')
      next if File.directory?(src)
      
      relative_path = src.sub("#{svn_path}/", '')
      dest = File.join(git_dir, relative_path)
      
      FileUtils.mkdir_p(File.dirname(dest))
      FileUtils.cp(src, dest)
    end
    
    # Stage all changes
    system('git', 'add', '-A', chdir: git_dir)
    
    # Check if there are changes to commit
    _, _, status = Open3.capture3('git', 'diff', '--cached', '--quiet', chdir: git_dir)
    unless status.success?
      # Commit changes
      commit_message = "Sync from SVN at #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}"
      system('git', 'commit', '-m', commit_message, chdir: git_dir)
      @job.append_output("Committed changes: #{commit_message}")
    else
      @job.append_output("No changes detected from SVN")
    end
  end
  
  def push_to_gitlab_from_dir(git_dir)
    gitlab_token = @user.gitlab_token
    return unless gitlab_token
    
    connector = Repositories::GitlabConnector.new(gitlab_token)
    project = connector.fetch_project(@repository.gitlab_project_id)
    
    if project[:success]
      gitlab_url = project[:project][:http_url_to_repo]
      push_url = gitlab_url.sub('https://', "https://oauth2:#{gitlab_token.decrypt_token}@")
      
      # Get current branch
      current_branch, _ = Open3.capture2('git', 'rev-parse', '--abbrev-ref', 'HEAD', chdir: git_dir)
      current_branch = current_branch.strip
      current_branch = 'main' if current_branch.empty?
      
      # Push to GitLab
      Open3.popen3('git', 'push', push_url, current_branch, chdir: git_dir) do |stdin, stdout, stderr, wait_thr|
        stdout.each_line { |line| @job.append_output("Push: #{line.strip}") }
        stderr.each_line { |line| @job.append_output("Push: #{line.strip}") }
        
        unless wait_thr.value.success?
          raise "Failed to push to GitLab"
        end
      end
    else
      raise "Failed to fetch GitLab project: #{project[:errors].join(', ')}"
    end
  end
  
  def get_latest_svn_revision_from_checkout(svn_path)
    output, _ = Open3.capture2('svn', 'info', '--show-item', 'revision', svn_path.to_s)
    output.strip.to_i
  rescue
    nil
  end
  
  def execute_svn_command(cmd, description)
    @job.append_output("Executing: #{description}")
    
    Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
      stdout.each_line do |line|
        @job.append_output("  #{line.strip}")
      end
      
      stderr.each_line do |line|
        @job.append_output("  ERROR: #{line.strip}")
      end
      
      unless wait_thr.value.success?
        raise "Command failed: #{description}"
      end
    end
  end
  
  def build_git_svn_clone_command
    cmd = ['git', 'svn', 'clone']
    
    # Add authentication if needed
    if @repository.auth_type == 'basic' && @repository.username.present?
      cmd += ['--username', @repository.username]
    end
    
    # Add standard layout if branches/tags exist
    if @repository.branch_strategy != 'none' || @repository.tag_strategy != 'none'
      cmd << '--stdlayout'
    end
    
    # Add the SVN URL and current directory
    cmd << @repository.svn_url
    cmd << '.'
    
    cmd
  end
  
  def add_gitlab_remote
    gitlab_token = @user.gitlab_token
    return unless gitlab_token
    
    connector = Repositories::GitlabConnector.new(gitlab_token)
    project = connector.fetch_project(@repository.gitlab_project_id)
    
    if project[:success]
      gitlab_url = project[:project][:http_url_to_repo]
      execute_command(['git', 'remote', 'add', 'gitlab', gitlab_url], "Add GitLab remote")
    else
      raise "Failed to fetch GitLab project: #{project[:errors].join(', ')}"
    end
  end
  
  def push_to_gitlab
    gitlab_token = @user.gitlab_token
    return unless gitlab_token
    
    connector = Repositories::GitlabConnector.new(gitlab_token)
    project = connector.fetch_project(@repository.gitlab_project_id)
    
    if project[:success]
      gitlab_url = project[:project][:http_url_to_repo]
      push_url = gitlab_url.sub('https://', "https://oauth2:#{gitlab_token.decrypt_token}@")
      
      # Get current branch
      current_branch = `git rev-parse --abbrev-ref HEAD`.strip
      current_branch = 'master' if current_branch.empty?
      
      execute_command(['git', 'push', 'gitlab', current_branch], "Push to GitLab")
    else
      raise "Failed to fetch GitLab project: #{project[:errors].join(', ')}"
    end
  end
  
  def get_latest_svn_revision
    # Since we're not using git-svn, we need to get revision from SVN directly
    output, _ = Open3.capture2('svn', 'info', '--show-item', 'revision', @repository.svn_url)
    output.strip.to_i
  rescue
    nil
  end
  
  def execute_command(cmd, description)
    @job.append_output("Executing: #{description}")
    
    Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
      # Handle authentication
      if @repository.auth_type == 'basic' && @repository.password.present? && cmd.join(' ').include?('git svn')
        stdin.puts @repository.password
        stdin.close
      end
      
      # Read output
      stdout.each_line do |line|
        @job.append_output("  #{line.strip}")
      end
      
      stderr.each_line do |line|
        @job.append_output("  ERROR: #{line.strip}")
      end
      
      unless wait_thr.value.success?
        raise "Command failed: #{description}"
      end
    end
  end
end