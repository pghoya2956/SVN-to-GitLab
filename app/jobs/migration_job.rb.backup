class MigrationJob
  include Sidekiq::Job
  
  sidekiq_options retry: 3, dead: false
  
  sidekiq_retry_in do |count, exception|
    case count
    when 0
      60 # 1 minute
    when 1
      300 # 5 minutes
    when 2
      600 # 10 minutes
    end
  end
  
  def perform(job_id)
    @job = Job.find(job_id)
    @repository = @job.repository
    @user = @job.user
    
    # Set current user for default scope
    User.current = @user
    
    begin
      @job.mark_as_running!
      @job.append_output("Starting SVN to GitLab migration...")
      
      # Step 1: Validate repository access
      validate_repository!
      
      # Step 2: Clone SVN repository
      local_path = clone_svn_repository
      
      # Step 3: Convert to Git
      git_path = convert_to_git(local_path)
      
      # Step 4: Apply migration strategy
      apply_migration_strategy(git_path)
      
      # Step 5: Push to GitLab
      gitlab_url = push_to_gitlab(git_path)
      
      # Step 6: Save git path for incremental sync
      @repository.update!(local_git_path: git_path)
      @job.append_output("Saved local git path for incremental sync")
      
      # Skip cleanup to preserve git repository for incremental sync
      # cleanup_temp_files(local_path, git_path)
      
      @job.mark_as_completed!(gitlab_url)
      @job.append_output("Migration completed successfully!")
      
    rescue => e
      @job.mark_as_failed!(e.message)
      raise e
    ensure
      User.current = nil
    end
  end
  
  private
  
  def validate_repository!
    @job.append_output("Validating SVN repository access...")
    @job.update(progress: 10)  # 10% for validation
    
    validator = Repositories::ValidatorService.new(@repository)
    result = validator.call
    
    unless result[:success]
      raise "Repository validation failed: #{result[:errors].join(', ')}"
    end
    
    @job.append_output("Repository validated successfully")
  end
  
  def clone_svn_repository
    @job.append_output("Cloning SVN repository...")
    @job.update(progress: 20)  # 20% for starting clone
    
    # Create temporary directory
    temp_dir = Rails.root.join('tmp', 'migrations', @job.id.to_s)
    FileUtils.mkdir_p(temp_dir)
    
    svn_path = temp_dir.join('svn_repo')
    
    # Build SVN clone command based on strategy
    cmd = build_svn_clone_command(svn_path)
    
    # Execute SVN clone
    Open3.popen3(*cmd) do |stdin, stdout, stderr, wait_thr|
      # Handle authentication
      if @repository.auth_type == 'basic' && @repository.username.present?
        stdin.puts @repository.username
        stdin.puts @repository.password
        stdin.close
      end
      
      # Read output
      stdout.each_line do |line|
        @job.append_output("SVN: #{line.strip}")
        update_progress_from_svn_output(line)
      end
      
      stderr.each_line do |line|
        @job.append_output("SVN Error: #{line.strip}")
      end
      
      unless wait_thr.value.success?
        raise "SVN clone failed"
      end
    end
    
    @job.update(progress: 40)  # 40% after clone complete
    svn_path.to_s
  end
  
  def build_svn_clone_command(target_path)
    cmd = ['svn', 'checkout']
    
    # Add authentication
    if @repository.auth_type == 'basic'
      cmd << '--username' << @repository.username if @repository.username.present?
      cmd << '--password' << @repository.password if @repository.password.present?
    end
    
    # Add revision limit for fast migration
    if @repository.migration_type == 'fast'
      cmd << '-r' << 'HEAD:1000'  # Last 1000 revisions
    end
    
    cmd << @repository.svn_url << target_path.to_s
    cmd
  end
  
  def convert_to_git(svn_path)
    @job.append_output("Converting to Git repository...")
    @job.update(progress: 50)  # 50% for conversion
    
    git_path = svn_path.sub('svn_repo', 'git_repo')
    FileUtils.mkdir_p(git_path)
    
    # Initialize git repository
    execute_command('git init', git_path)
    execute_command(['git', 'config', 'user.name', @user.email.split('@').first], git_path)
    execute_command(['git', 'config', 'user.email', @user.email], git_path)
    execute_command(['git', 'branch', '-M', 'main'], git_path)  # Set default branch to main
    
    # Copy files from SVN
    FileUtils.cp_r(Dir["#{svn_path}/*"], git_path, remove_destination: true)
    
    # Remove .svn directories
    Dir.glob("#{git_path}/**/.svn", File::FNM_DOTMATCH).each do |svn_dir|
      FileUtils.rm_rf(svn_dir)
    end
    
    # Apply ignore patterns
    apply_ignore_patterns(git_path)
    
    # Create initial commit
    execute_command('git add .', git_path)
    commit_message = @repository.commit_message_prefix.present? ? 
      "#{@repository.commit_message_prefix} Initial import from SVN" : 
      "Initial import from SVN"
    execute_command(['git', 'commit', '-m', commit_message], git_path)
    
    git_path
  end
  
  def apply_migration_strategy(git_path)
    @job.append_output("Applying migration strategy...")
    @job.update(progress: 60)  # 60% for strategy
    
    strategy_service = Repositories::MigrationStrategyService.new(@repository)
    
    # Apply authors mapping
    if @repository.authors_mapping.present?
      apply_authors_mapping(git_path, strategy_service.parse_authors_mapping)
    end
    
    # Handle large files
    if @repository.large_file_handling == 'git-lfs'
      setup_git_lfs(git_path)
    end
    
    @job.append_output("Migration strategy applied")
  end
  
  def apply_ignore_patterns(git_path)
    return unless @repository.ignore_patterns.present?
    
    gitignore_path = File.join(git_path, '.gitignore')
    File.open(gitignore_path, 'a') do |f|
      f.puts "\n# Patterns from migration configuration"
      f.puts @repository.ignore_patterns
    end
  end
  
  def apply_authors_mapping(git_path, mapping)
    return if mapping.empty?
    
    @job.append_output("Applying authors mapping...")
    
    mapping.each do |svn_author, git_author|
      name, email = git_author.match(/^(.+) <(.+)>$/).captures
      execute_command(['git', 'config', "user.#{svn_author}.name", name], git_path)
      execute_command(['git', 'config', "user.#{svn_author}.email", email], git_path)
    end
  end
  
  def setup_git_lfs(git_path)
    @job.append_output("Setting up Git LFS...")
    
    execute_command('git lfs install', git_path)
    
    # Track large files
    extensions = %w[zip tar gz bz2 7z rar exe dmg iso jar war ear]
    extensions.each do |ext|
      execute_command("git lfs track '*.#{ext}'", git_path)
    end
    
    # Track files over size limit
    max_size = @repository.max_file_size_mb || 100
    execute_command("git lfs track '*.{*}' --above=#{max_size}mb", git_path)
    
    execute_command('git add .gitattributes', git_path)
    # Check if there are changes to commit
    _, _, status = Open3.capture3('git diff --cached --quiet', chdir: git_path)
    unless status.success?
      execute_command(['git', 'commit', '-m', 'Configure Git LFS'], git_path)
    end
  end
  
  def push_to_gitlab(git_path)
    @job.append_output("Pushing to GitLab...")
    @job.update(progress: 70)  # 70% for push
    
    # Get GitLab project details
    connector = Repositories::GitlabConnector.new(@user.gitlab_token)
    project = connector.fetch_project(@repository.gitlab_project_id)
    
    unless project[:success]
      raise "Failed to fetch GitLab project: #{project[:errors].join(', ')}"
    end
    
    gitlab_url = project[:project][:http_url_to_repo]
    
    Dir.chdir(git_path) do
      # Add GitLab remote
      system('git', 'remote', 'add', 'gitlab', gitlab_url)
      
      # Push with authentication
      push_url = gitlab_url.sub('https://', "https://oauth2:#{@user.gitlab_token.decrypt_token}@")
      
      # First check which branch we're on
      current_branch = `git branch --show-current`.strip
      current_branch = 'main' if current_branch.empty?
      
      # Try normal push first
      Open3.popen3('git', 'push', '-u', push_url, current_branch) do |stdin, stdout, stderr, wait_thr|
        stdout.each_line { |line| @job.append_output("Push: #{line.strip}") }
        stderr.each_line { |line| @job.append_output("Push: #{line.strip}") }
        
        unless wait_thr.value.success?
          @job.append_output("Normal push failed, trying force push...")
          
          # Try force push as fallback
          Open3.popen3('git', 'push', '-u', '--force', push_url, current_branch) do |stdin2, stdout2, stderr2, wait_thr2|
            stdout2.each_line { |line| @job.append_output("Force Push: #{line.strip}") }
            stderr2.each_line { |line| @job.append_output("Force Push: #{line.strip}") }
            
            unless wait_thr2.value.success?
              raise "Failed to push to GitLab even with force"
            end
          end
        end
      end
    end
    
    project[:project][:web_url]
  end
  
  def cleanup_temp_files(svn_path, git_path)
    @job.append_output("Cleaning up temporary files...")
    
    FileUtils.rm_rf(svn_path) if svn_path && File.exist?(svn_path)
    FileUtils.rm_rf(git_path) if git_path && File.exist?(git_path)
    
    @job.append_output("Cleanup completed")
  end
  
  def update_progress_from_svn_output(line)
    # Parse SVN progress from output
    if line =~ /Checked out revision (\d+)/
      revision = $1.to_i
      # Update progress based on revision
      @job.update(processed_commits: revision)
    end
  end
  
  def execute_command(cmd, working_dir = nil)
    if cmd.is_a?(String)
      # For simple string commands
      if working_dir
        system(cmd, chdir: working_dir)
      else
        system(cmd)
      end
    else
      # For array commands
      if working_dir
        system(*cmd, chdir: working_dir)
      else
        system(*cmd)
      end
    end
  end
end